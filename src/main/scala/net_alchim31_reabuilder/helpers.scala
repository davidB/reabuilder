package net_alchim31_reabuilder
package helpers

import net_alchim31_reabuilder.helpers.FileSystemChangesHelper
import net_alchim31_reabuilder.api.{FileSystemChanges, FilePath}
import net_alchim31_reabuilder.impl0.{FilePath0, FileSystemChanges0, FileSystemChangesEmpty}

object FilePathImplicits extends FilePathFilterFactory {
  import net_alchim31_reabuilder.api.{FilePath, FilePathFilter}
  import java.util.regex.Pattern

  implicit def toFilePathFilter(s : String) : FilePathFilter = {
    if (s.indexOf("**") > -1 || s.indexOf("*.") > -1) {
      glob(s)
    } else {
      regex(Pattern.compile(s))
    }
  }

  implicit def toFilePath(s : String)(implicit basedir : FilePath0) : FilePath = new FilePath0(s, Some(basedir))
}

trait FilePathFilterFactory {
  import net_alchim31_reabuilder.api.{FilePath, FilePathFilter}
  import net_alchim31_utils.Regexps
  import java.util.regex.Pattern

  def regex(pattern : Pattern, root : Option[FilePath] = None) : FilePathFilter = {
    (p : FilePath) => pattern.matcher(p.rpath).matches()
  }
  def glob(pattern : String, root : Option[FilePath] = None) : FilePathFilter = {
    regex(Regexps.globToRegexPattern(pattern), root)
  }
  def compose(includes : List[FilePathFilter], excludes : List[FilePathFilter]) : FilePathFilter = (p : FilePath) => {
    val isExcluded = excludes.foldLeft(false)((r, acceptor : FilePathFilter) => r || acceptor(p))
    val isIncluded = includes match {
      case Nil => true
      case l => l.foldLeft(false)((r, acceptor : FilePathFilter) => r || acceptor(p))
    }
    !isExcluded && isIncluded    
  }
}

object FileSystemChangesHelper {
  import net_alchim31_reabuilder.api.{FilePath, FilePathFilter}
  import net_alchim31_reabuilder.api.FileSystemChanges
  
  def filterForAccept(v : FileSystemChanges, f : FilePathFilter) = new FileSystemChanges {
    def modifiedOrCreated : Seq[FilePath] = v.modifiedOrCreated.filter(f)
    def deleted :  Seq[FilePath] = v.deleted.filter(f)
    def renamed : Seq[(FilePath,FilePath)] = v.renamed.filter(t => f(t._1) || f(t._2))
  }
  
  /**
   * basic merge algo that need lot of improvements see below (TODO)
   * 
   * @TODO deleted on a created/renamed dest/modified => nothing
   * @TODO renamed on a created => created(newest)
   */
  def merge(v1 : FileSystemChanges, v2 : FileSystemChanges) = {
    if (v2.isEmpty) {
      v1
    } else if (v1.isEmpty) {
      v2
    } else {
      new FileSystemChanges {
        lazy val modifiedOrCreated = (v1.modifiedOrCreated ++ v2.modifiedOrCreated).distinct
        lazy val deleted = (v1.deleted ++ v2.deleted).distinct
        lazy val renamed = (v1.renamed ++ v2.renamed).distinct
      }
    }
  }
}

/**
 * Helper class provide as quick and dirty solution for Builders that can compute and return
 * FileSystemChanges generated by a run.
 * The class record every changes made on a directory (and subdirectory) **regardless who/what made the change**,
 * from end of constructor call to stop()
 * If possible avoid using this class.
 */
class FileSystemChangesRecorder(dir : FilePath) {
  import net.contentobjects.jnotify.{JNotify, JNotifyListener}

  private val _recorder = new Recorder()
  private val _watchId = JNotify.addWatch(dir.fullpath, JNotify.FILE_ANY, true, _recorder)

  /**
   * Stop recording change and return the sum of changes.
   * @return the recorded changes
   */
  def stop() : FileSystemChanges = {
    if (!JNotify.removeWatch(_watchId)) {
      // invalid watch ID specified.
    }
    _recorder.recorded
  }

  private class Recorder extends JNotifyListener {
    var recorded : FileSystemChanges = FileSystemChangesEmpty
    
    def fileRenamed(wid : Int, rootPath : String,  oldName : String, newName : String) {
      send(new FileSystemChanges0(renamed=List((toFilePath(rootPath, oldName), toFilePath(rootPath, newName)))))

    }
    def fileModified(wid : Int, rootPath : String, name : String) {
      send(new FileSystemChanges0(modifiedOrCreated = List(toFilePath(rootPath, name))))
    }
    def fileDeleted(wid : Int, rootPath : String, name : String) {
      send(new FileSystemChanges0(deleted = List(toFilePath(rootPath, name))))
    }
    def fileCreated(wid : Int, rootPath : String, name : String) {
      send(new FileSystemChanges0(modifiedOrCreated = List(toFilePath(rootPath, name))))
    }

    private def toFilePath(rootPath : String, name : String) : FilePath = {
      new FilePath0(name, Some(new FilePath0(rootPath)))
    }
    private def send(n : FileSystemChanges) {
      recorded = FileSystemChangesHelper.merge(recorded, n)
    }
  }
}